// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TournamentPrizeDistribution {
    address public organizer;
    uint public totalPrizePool;
    bool public prizeDistributed;

    address[3] public winners;
    uint[3] public prizeAmounts;

    constructor() {
        organizer = msg.sender;
        prizeDistributed = false;
    }

    // Organizer can deposit the prize pool
    function depositPrize() external payable {
        require(msg.sender == organizer, "Only organizer can deposit");
        require(msg.value > 0, "Prize amount must be greater than zero");
        totalPrizePool += msg.value;
    }

    // Organizer distributes the prize to top 3 winners
    function distributePrizes(address[3] calldata _winners, uint[3] calldata _amounts) external {
        require(msg.sender == organizer, "Only organizer can distribute");
        require(!prizeDistributed, "Prizes already distributed");
        require(_amounts[0] + _amounts[1] + _amounts[2] <= totalPrizePool, "Insufficient prize pool");

        winners = _winners;
        prizeAmounts = _amounts;

        for (uint i = 0; i < 3; i++) {
            payable(_winners[i]).transfer(_amounts[i]);
        }

        prizeDistributed = true;
    }

    // View prize info of a specific winner
    function getWinnerInfo(uint index) external view returns (address winner, uint prize) {
        require(index < 3, "Invalid index");
        return (winners[index], prizeAmounts[index]);
    }

    // Organizer can withdraw remaining funds after distribution
    function withdrawRemainingFunds() external {
        require(msg.sender == organizer, "Only organizer can withdraw");
        require(prizeDistributed, "Prizes not distributed yet");

        uint remainingBalance = address(this).balance;
        require(remainingBalance > 0, "No remaining balance");

        payable(organizer).transfer(remainingBalance);
    }

    // Allow contract to receive ETH directly
    receive() external payable {
        totalPrizePool += msg.value;
    }

    // Fallback function to accept ETH sent to the contract by mistake
    fallback() external payable {
        totalPrizePool += msg.value;
    }

    // View current contract balance
    function getContractBalance() external view returns (uint) {
        return address(this).balance;
    }

    // Organizer can reset the tournament for reuse
    function resetTournament() external {
        require(msg.sender == organizer, "Only organizer can reset");
        require(prizeDistributed, "Cannot reset before distributing prizes");

        delete winners;
        delete prizeAmounts;
        totalPrizePool = address(this).balance;
        prizeDistributed = false;
    }

    // Update a specific winner before prize distribution
    function updateWinner(uint index, address newWinner, uint newAmount) external {
        require(msg.sender == organizer, "Only organizer can update");
        require(!prizeDistributed, "Cannot update after distribution");
        require(index < 3, "Invalid index");

        winners[index] = newWinner;
        prizeAmounts[index] = newAmount;
    }

    // Change the organizer of the tournament
    function changeOrganizer(address newOrganizer) external {
        require(msg.sender == organizer, "Only current organizer can change");
        require(newOrganizer != address(0), "New organizer cannot be zero address");

        organizer = newOrganizer;
    }

    // Returns true if a given address is a winner
    function isWinner(address _addr) external view returns (bool) {
        for (uint i = 0; i < 3; i++) {
            if (winners[i] == _addr) {
                return true;
            }
        }
        return false;
    }

    // View all winners and their prizes
    function getAllWinners() external view returns (address[3] memory, uint[3] memory) {
        return (winners, prizeAmounts);
    }

    // Emergency withdrawal by organizer if something goes wrong
    function emergencyWithdraw() external {
        require(msg.sender == organizer, "Only organizer can withdraw");
        uint balance = address(this).balance;
        require(balance > 0, "No funds to withdraw");

        totalPrizePool = 0;
        payable(organizer).transfer(balance);
    }

    // View how much a specific winner will receive
    function getPrizeAmount(address _winner) external view returns (uint prize) {
        for (uint i = 0; i < 3; i++) {
            if (winners[i] == _winner) {
                return prizeAmounts[i];
            }
        }
        return 0;
    }
}

